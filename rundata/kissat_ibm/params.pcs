ands{true,false}[true] #             extract and eliminate and gates [true]
autarky{true,false}[true] #           enable autarky reasoning [true]
autarkydelay{true,false}[false] #      delay autarky reasoning [false]
backbone[0,2][1]i #            binary clause backbone (2=eager) [1]
backbonedelay{true,false}[false] #     delay backbone computation [false]
backboneeffort[0,1e5][20]i #    effort in per mille [20]
backbonefocus{true,false}[false] #     focus on not-yet-tried literals [false]
backbonekeep{true,false}[true] #      keep backbone candidates [true]
backbonemaxrounds[1,1e9][1e3]i #   maximum backbone rounds [1e3]
backbonerounds[1,1e9][100]i #      backbone rounds limit [100]
backward{true,false}[true] #          backward subsumption in BVE [true]
bumpreasons{true,false}[true] #       bump reason side literals too [true]
bumpreasonslimit[1,1e9][10]i #    relative reason literals limit [10]
bumpreasonsrate[1,1e9][10]i #     decision rate limit [10]
cachesample{true,false}[true] #       sample cached assignments [true]
chrono{true,false}[true] #            allow chronological backtracking [true]
chronolevels[0,1e9][100]i #        maximum jumped over levels [100]
compact{true,false}[true] #           enable compacting garbage collection [true]
compactlim[0,100][10]i #        compact inactive limit (in percent) [10]
decay[1,200][50]i #             per mille scores decay [50]
definitioncores[1,100][2]i #   how many cores [2]
definitions{true,false}[true] #       extract general definitions [true]
defraglim[50,100][75]i #        usable defragmentation limit in percent [75]
defragsize[10,1e9][262144]i #         size defragmentation limit [2^18]
delay[0,10][2]i #              maximum delay (autarky, failed, ...) [2]
eagersubsume[0,100][20]i #      eagerly subsume recently learned clauses [20]
eliminate{true,false}[true] #         bounded variable elimination (BVE) [true]
eliminatebound[0,8192][16]i #   maximum elimination bound [16]
eliminateclslim[1,1e9][100]i #     elimination clause size limit [100]
eliminatedelay{true,false}[false] #    delay variable elimination [false]
eliminateeffort[0,2e3][100]i #   effort in per mille [100]
eliminateheap{true,false}[false] #     use heap to schedule elimination [false]
eliminateinit[0,1e9][500]i #       initial elimination interval [500]
eliminateint[10,1e9][500]i #       base elimination interval [500]
eliminatekeep{true,false}[true] #     keep elimination candidates [true]
eliminateocclim[0,1e9][1e3]i #     elimination occurrence limit [1e3]
eliminaterounds[1,1e3][2]i #   elimination rounds limit [2]
emafast[10,1e6][33]i #          fast exponential moving average window [33]
emaslow[100,1e6][1e5]i #         slow exponential moving average window [1e5]
equivalences{true,false}[true] #      extract and eliminate equivalence gates [true]
extract{true,false}[true] #           extract gates in variable elimination [true]
failed{true,false}[true] #            failed literal probing [true]
failedcont[0,100][90]i #        continue if many failed (in percent) [90]
faileddelay{true,false}[true] #       delay failed literal probing [true]
failedeffort[0,1e8][50]i #      effort in per mille [50]
failedrounds[1,100][2]i #      failed literal probing rounds [2]
forcephase{true,false}[false] #        force initial phase [false]
forward{true,false}[true] #           forward subsumption in BVE [true]
forwardeffort[0,1e6][100]i #     effort in per mille [100]
hyper{true,false}[true] #             on-the-fly hyper binary resolution [true]
ifthenelse{true,false}[true] #        extract and eliminate if-then-else gates [true]
incremental{true,false}[false] #       enable incremental solving [false]
mineffort[0,1e9][1e4]i #           minimum absolute effort [1e4]
minimize{true,false}[true] #          learned clause minimization [true]
minimizedepth[1,1e6][1e3]i #     minimization depth [1e3]
minimizeticks{true,false}[true] #     count ticks in minimize and shrink [true]
modeconflicts[10,1e8][1e3]i #    initial focused conflicts limit [1e3]
#modeticks[1e3,1e16][1e8]i #         initial focused ticks limit [1e8] TODO seems to make kissat crash?
otfs{true,false}[true] #              on-the-fly strengthening [true]
phase{true,false}[true] #             initial decision phase [true]
phasesaving{true,false}[true] #       enable phase saving [true]
probe{true,false}[true] #             enable probing [true]
probedelay{true,false}[false] #        delay probing [false]
probeinit[0,1e9][100]i #           initial probing interval [100]
probeint[2,1e9][100]i #            probing interval [100]
profile[0,4][2]i #             profile level [2]
promote{true,false}[true] #           promote clauses [true]
quiet{true}[true] #             disable all messages [false]
really{true,false}[true] #            delay preprocessing after scheduling [true]
reap{true,false}[false] #              enable radix-heap for shrinking [false]
reduce{true,false}[true] #            learned clause reduction [true]
reducefraction[10,100][75]i #   reduce fraction in percent [75]
reduceinit[2,1e5][300]i #        initial reduce interval [300]
reduceint[2,1e5][1e3]i #         base reduce interval [1e3]
reducerestart[0,2][0]i #       restart at reduce (1=stable,2=always) [0]
reluctant{true,false}[true] #         stable reluctant doubling restarting [true]
reluctantint[2,32768][1024]i #     reluctant interval [2^10]
reluctantlim[0,1073741824][1048576]i #     reluctant limit (0=unlimited) [2^20]
rephase{true,false}[true] #           reinitialization of decision phases [true]
rephasebest{true,false}[true] #       rephase best phase [true]
rephaseinit[10,1e5][1e3]i #      initial rephase interval [1e3]
rephaseint[10,1e5][1e3]i #       base rephase interval [1e3]
rephaseinverted{true,false}[true] #   rephase inverted phase [true]
rephaseoriginal{true,false}[true] #   rephase original phase [true]
rephaseprefix[0,1e9][1]i #       initial 'OI' prefix repetition [1]
rephasewalking{true,false}[true] #    rephase walking phase [true]
restart{true,false}[true] #           enable restarts [true]
restartint[1,1e4][1]i #        base restart interval [1]
restartmargin[0,25][10]i #      fast/slow margin in percent [10]
restartreusetrail{true,false}[true] # restarts reuse trail [true]
#seed=0...                random seed [0]
shrink[0,3][3]i #              learned clauses (1=bin,2=lrg,3=rec) [3]
shrinkminimize{true,false}[true] #    minimize during shrinking [true]
simplify{true,false}[true] #          enable probing and elimination [true]
stable[0,2][1]i #              enable stable search mode [1]
#statistics{true,false}[false] #        print complete statistics [false]
substitute{true,false}[true] #        equivalent literal substitution [true]
substituteeffort[1,1e3][10]i #  effort in per mille [10]
substituterounds[1,100][2]i #  maximum substitution rounds [2]
subsumeclslim[1,1e9][1e3]i #       subsumption clause size limit [1e3]
subsumeocclim[0,1e9][1e3]i #       subsumption occurrence limit [1e3]
sweep{true,false}[true] #             enable SAT sweeping [true]
sweepclauses[0,1e9][1e3]i #        maximum environment clauses [1e3]
sweepdepth[0,1e9][2]i #          environment depth [2]
sweepeffort[0,1e4][20]i #       effort in per mille [20]
sweepmaxdepth[2,1e4][4]i #       maximum environment depth [4]
sweepvars[0,1e9][100]i #           maximum environment variables [100]
target[0,2][1]i #              target phases (1=stable,2=focused) [1]
ternary{true,false}[true] #           enable hyper ternary resolution [true]
ternarydelay{true,false}[true] #      delay hyper ternary resolution [true]
ternaryeffort[0,2e3][70]i #     effort in per mille [70]
ternaryheap{true,false}[true] #       use heap to schedule ternary resolution [true]
ternarymaxadd[0,1e4][20]i #     maximum clauses added in percent [20]
tier1[1,100][2]i #             learned clause tier one glue limit [2]
tier2[1,1e3][6]i #             learned clause tier two glue limit [6]
transitive{true,false}[true] #        transitive reduction of binary clauses [true]
transitiveeffort[0,2e3][20]i #  effort in per mille [20]
transitivekeep{true,false}[true] #    keep transitivity candidates [true]
tumble{true,false}[true] #            tumbled external indices order [true]
#verbose[0,3][0]i #             verbosity level [0]
vivify{true,false}[true] #            vivify clauses [true]
vivifyeffort[0,1e3][100]i #      effort in per mille [100]
vivifyimply[0,2][2]i #         remove implied redundant clauses [2]
vivifyirred[1,100][1]i #       relative irredundant effort [1]
vivifykeep{true,false}[false] #        keep vivification candidates [false]
vivifytier1[1,100][3]i #       relative tier1 effort [3]
vivifytier2[1,100][6]i #       relative tier2 effort [6]
walkeffort[0,1e6][5]i #        effort in per mille [5]
walkfit{true,false}[true] #           fit CB value to average clause length [true]
walkinitially{true,false}[false] #     initial local search [false]
walkreuse[0,2][2]i #           reuse walking results (2=always) [1]
walkweighted{true,false}[true] #      use clause weights [true]
xors{true,false}[true] #              extract and eliminate XOR gates [true]
xorsbound[0,8192][1]i #        minimum elimination bound [1]
xorsclslim[3,31][5]i #         XOR extraction clause size limit [5]
